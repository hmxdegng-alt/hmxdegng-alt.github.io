<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Physics Ball</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #222;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            background: #222;
        }
    </style>
</head>
<body>
<button id="menuBtn" style="position:fixed;top:10px;left:10px;z-index:10;">Menu</button>
<div id="menu" style="display:none;position:fixed;top:40px;left:10px;z-index:10;background:#333;padding:10px;border-radius:8px;color:#fff;">
    <label for="ballCount">Number of red balls: </label>
    <select id="ballCount"></select>
    <br><br>
    <label for="bgImageInput">Background image: </label>
    <input type="file" id="bgImageInput" accept="image/*">
    <br>
    <label for="bgOpacity">Background opacity: </label>
    <input type="range" id="bgOpacity" min="0" max="1" step="0.01" value="1" style="width:100px;">
    <span id="bgOpacityValue">1</span>
    <br><br>
    <label for="ballImageInput">Grabbable ball image: </label>
    <input type="file" id="ballImageInput" accept="image/*">
</div>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);


const BALL_RADIUS = 50;
const GRAVITY = 0.6;
const FRICTION = 0.99;
const BOUNCE = 0.8;


// Array of red balls (not interactable, always moving)
let redBalls = [];
function createRedBall() {
    const angle = Math.random() * Math.PI * 2;
    const speed = 6 + Math.random() * 2;
    return {
        x: Math.random() * (canvas.width - 2 * BALL_RADIUS) + BALL_RADIUS,
        y: Math.random() * (canvas.height - 2 * BALL_RADIUS) + BALL_RADIUS,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        radius: BALL_RADIUS,
        color: 'red'
    };
}
function setRedBallCount(n) {
    while (redBalls.length < n) redBalls.push(createRedBall());
    while (redBalls.length > n) redBalls.pop();
}
setRedBallCount(1);

let ball = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    vx: 4,
    vy: 2,
    radius: BALL_RADIUS,
    color: '#4af',
    isDragging: false,
    offsetX: 0,
    offsetY: 0,
    lastX: 0,
    lastY: 0,
    lastVX: 0,
    lastVY: 0
};


let ballImage = null;
let ballImageURL = null;
function drawBall(b, isMainBall = false) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.closePath();
    ctx.shadowColor = "#000";
    ctx.shadowBlur = 20;
    ctx.clip();
    if (isMainBall && ballImage) {
        ctx.drawImage(ballImage, b.x - b.radius, b.y - b.radius, b.radius * 2, b.radius * 2);
    } else {
        ctx.fillStyle = b.color;
        ctx.fill();
    }
    ctx.shadowBlur = 0;
    ctx.restore();
}


function updateBall() {
    if (!ball.isDragging) {
        ball.vy += GRAVITY;
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Bounce off left/right
        if (ball.x - ball.radius < 0) {
            ball.x = ball.radius;
            ball.vx = -ball.vx * BOUNCE;
        }
        if (ball.x + ball.radius > canvas.width) {
            ball.x = canvas.width - ball.radius;
            ball.vx = -ball.vx * BOUNCE;
        }
        // Bounce off top/bottom
        if (ball.y - ball.radius < 0) {
            ball.y = ball.radius;
            ball.vy = -ball.vy * BOUNCE;
        }
        if (ball.y + ball.radius > canvas.height) {
            ball.y = canvas.height - ball.radius;
            ball.vy = -ball.vy * BOUNCE;
        }
    }
}


function updateRedBalls() {
    for (let i = 0; i < redBalls.length; ++i) {
        let b = redBalls[i];
        b.x += b.vx;
        b.y += b.vy;
        // Bounce off left/right
        if (b.x - b.radius < 0) {
            b.x = b.radius;
            b.vx = -b.vx;
        }
        if (b.x + b.radius > canvas.width) {
            b.x = canvas.width - b.radius;
            b.vx = -b.vx;
        }
        // Bounce off top/bottom
        if (b.y - b.radius < 0) {
            b.y = b.radius;
            b.vy = -b.vy;
        }
        if (b.y + b.radius > canvas.height) {
            b.y = canvas.height - b.radius;
            b.vy = -b.vy;
        }
    }
}


// Ball-ball collision (elastic) between red balls and main ball
function handleBallCollision() {
    // Red balls vs main ball
    for (let i = 0; i < redBalls.length; ++i) {
        let b = redBalls[i];
        const dx = b.x - ball.x;
        const dy = b.y - ball.y;
        const dist = Math.hypot(dx, dy);
        if (dist < ball.radius + b.radius) {
            const overlap = ball.radius + b.radius - dist;
            const nx = dx / dist;
            const ny = dy / dist;
            b.x += nx * overlap / 2;
            b.y += ny * overlap / 2;
            ball.x -= nx * overlap / 2;
            ball.y -= ny * overlap / 2;
            const kx = (b.vx - ball.vx);
            const ky = (b.vy - ball.vy);
            const p = 2 * (nx * kx + ny * ky) / 2;
            b.vx -= p * nx;
            b.vy -= p * ny;
            ball.vx += p * nx;
            ball.vy += p * ny;
        }
    }
    // Red balls vs each other
    for (let i = 0; i < redBalls.length; ++i) {
        for (let j = i + 1; j < redBalls.length; ++j) {
            let a = redBalls[i], b = redBalls[j];
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.hypot(dx, dy);
            if (dist < a.radius + b.radius) {
                const overlap = a.radius + b.radius - dist;
                const nx = dx / dist;
                const ny = dy / dist;
                a.x -= nx * overlap / 2;
                a.y -= ny * overlap / 2;
                b.x += nx * overlap / 2;
                b.y += ny * overlap / 2;
                const kx = (b.vx - a.vx);
                const ky = (b.vy - a.vy);
                const p = 2 * (nx * kx + ny * ky) / 2;
                b.vx -= p * nx;
                b.vy -= p * ny;
                a.vx += p * nx;
                a.vy += p * ny;
            }
        }
    }
}




let bgImage = null;
let bgImageURL = null;
let bgOpacity = 1;
function drawBackground() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (bgImage) {
        ctx.save();
        ctx.globalAlpha = bgOpacity;
        ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
        ctx.globalAlpha = 1;
        ctx.restore();
    }
}
// Background opacity slider logic
const bgOpacitySlider = document.getElementById('bgOpacity');
const bgOpacityValue = document.getElementById('bgOpacityValue');
bgOpacitySlider.oninput = function() {
    bgOpacity = parseFloat(bgOpacitySlider.value);
    bgOpacityValue.textContent = bgOpacity;
};

function animate() {
    drawBackground();
    updateBall();
    updateRedBalls();
    handleBallCollision();
    drawBall(ball, true);
    for (let i = 0; i < redBalls.length; ++i) drawBall(redBalls[i]);
    requestAnimationFrame(animate);
}
animate();
// Grabbable ball image upload logic
const ballImageInput = document.getElementById('ballImageInput');
ballImageInput.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    if (ballImageURL) URL.revokeObjectURL(ballImageURL);
    ballImageURL = URL.createObjectURL(file);
    const img = new window.Image();
    img.onload = function() {
        ballImage = img;
    };
    img.src = ballImageURL;
};
// Background image upload logic
const bgImageInput = document.getElementById('bgImageInput');
bgImageInput.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    if (bgImageURL) URL.revokeObjectURL(bgImageURL);
    bgImageURL = URL.createObjectURL(file);
    const img = new window.Image();
    img.onload = function() {
        bgImage = img;
    };
    img.src = bgImageURL;
};
// Menu logic
const menuBtn = document.getElementById('menuBtn');
const menu = document.getElementById('menu');
const ballCount = document.getElementById('ballCount');
// Populate dropdown
for (let i = 0; i <= 10; ++i) {
    let opt = document.createElement('option');
    opt.value = i;
    opt.textContent = i;
    ballCount.appendChild(opt);
}
ballCount.value = 1;
menuBtn.onclick = () => {
    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
};
ballCount.onchange = () => {
    setRedBallCount(parseInt(ballCount.value));
};

// Mouse/touch events
function isInsideBall(x, y) {
    return Math.hypot(x - ball.x, y - ball.y) < ball.radius;
}

function onPointerDown(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    if (isInsideBall(x, y)) {
        ball.isDragging = true;
        ball.offsetX = x - ball.x;
        ball.offsetY = y - ball.y;
        ball.lastX = x;
        ball.lastY = y;
        ball.lastVX = 0;
        ball.lastVY = 0;
    }
}

function onPointerMove(e) {
    if (!ball.isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    ball.lastVX = x - ball.lastX;
    ball.lastVY = y - ball.lastY;
    ball.x = x - ball.offsetX;
    ball.y = y - ball.offsetY;
    ball.lastX = x;
    ball.lastY = y;
}

function onPointerUp(e) {
    if (ball.isDragging) {
        ball.isDragging = false;
        ball.vx = ball.lastVX;
        ball.vy = ball.lastVY;
    }
}

canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
canvas.addEventListener('mouseup', onPointerUp);
canvas.addEventListener('mouseleave', onPointerUp);

canvas.addEventListener('touchstart', onPointerDown, {passive: false});
canvas.addEventListener('touchmove', onPointerMove, {passive: false});
canvas.addEventListener('touchend', onPointerUp, {passive: false});
canvas.addEventListener('touchcancel', onPointerUp, {passive: false});
</script>
</body>
</html>